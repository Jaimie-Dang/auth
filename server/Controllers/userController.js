const UserModel = require("../Models/userModel");
const otp_generator = require("otp-generator");
const bcrypt = require("bcrypt");
const jwt = require("jsonwebtoken");
// to send mail to user (dich vu gui mail)
const sendEmail = require("../EmailService/Email");
const asyncHandler = require("express-async-handler");
const mongoose = require("mongoose");
const { populate } = require("../Models/course");

//*********************************** */
const register = async (req, res) => {
  try {
    console.log(req.body);

    // Check user: be existed or not!
    const isUserExisting = await UserModel.findOne({ email: req.body.email });

    if (isUserExisting) {
      console.log("User already exists");
      return res
        .status(400)
        .json({ message: `User with ${req.body.email} already exists` });
    }

    // verificationToken
    const verificationToken = otp_generator.generate(6, {
      upperCaseAlphabets: false,
      specialChars: false,
    });

    // Date
    const expires = new Date();
    expires.setMinutes(expires.getMinutes() + 5); // After 5 minuts, it will be expired

    // Hash password
    const hashedPassword = await bcrypt.hash(req.body.password, 10);

    //-------------------------------------------
    const newUser = await UserModel({
      username: req.body.username,
      email: req.body.email,
      password: hashedPassword,
      verificationToken: {
        token: verificationToken,
        expires: expires,
      },
    });

    console.log(newUser);

    // Save to DB: by newUser.save()
    await newUser.save();

    // send mail to user with register
    const emailBody = `<p>Please click on the link to verify your account. <b>http://localhost:5000/user/verify/${verificationToken}</b></p>`;
    const subject = `Verification Email`;
    await sendEmail(req.body.email, subject, emailBody);

    // response
    res.json({ message: "Verfication link sent to your email." });
  } catch (error) {
    res.json({ message: "Something went wrong" });
  }
};

//*********************************** */
const login = async (req, res) => {
  try {
    console.log(req.body);
    // Check user: be existed or not!
    const isUserExisting = await UserModel.findOne({ email: req.body.email });

    console.log(isUserExisting);
    if (!isUserExisting) {
      if (req.body.autoGenerated) {
        // Create password
        const password = otp_generator.generate(12) + "!1";

        console.log(password);

        // hash password
        const hashPassword = await bcrypt.hash(password, 10);
        // create new User
        const newUser = await UserModel({
          username: req.body.username,
          email: req.body.email,
          password: hashPassword,
          isVerified: true,
        });
        console.log(newUser);

        await newUser.save();

        // create a jwt
        const jwtPayload = {
          _id: newUser._id,
        };

        const token = jwt.sign(jwtPayload, process.env.SECRET, {
          expiresIn: "10m",
        });

        // send mail to user with register
        const emailBody = `<p>Account Created Successfully. Your password is <b>${password}</b> <br> Please change it.</p>`;
        const subject = `Account Create VIA Social`;
        await sendEmail(req.body.email, subject, emailBody);

        return res.status(200).json({ message: "Logged in via social", token });
      }

      return res
        .status(400)
        .json({ message: `User with ${req.body.email} don't exists` });
    }

    if (!isUserExisting.isVerified) {
      return res.status(400).json({
        message: `User is not verified. Please click the link in your email to verify`,
      });
    }
    if (!req.body.autoGenerated) {
      const isPasswordCorrect = await bcrypt.compare(
        req.body.password,
        isUserExisting.password
      );

      if (!isPasswordCorrect) {
        return res.status(400).json({
          message: `password is not corrected. Please enter again`,
        });
      }
    }

    // create a jwt
    const jwtPayload = {
      id: isUserExisting._id,
    };

    const token = jwt.sign(jwtPayload, process.env.SECRET, {
      expiresIn: "10m",
    });
    console.log(token);

    res.json({
      message: `User Logged in successfully`,
      token,
    });
  } catch (error) {
    res.status(500).json({
      message: `Something went wrong`,
    });
  }
};

//*********************************** */
const verifyUser = async (req, res) => {
  try {
    console.log(req.params);

    const { token } = req.params;

    const isTokenValid = await UserModel.findOne({
      "verificationToken.token": token,
      "verificationToken.expires": { $gt: new Date() },
    });

    console.log(isTokenValid);

    if (!isTokenValid) {
      return res.send(
        `<p>Token Invalid or Expired.</p> <a href="http://localhost:5000/user/resend_Verification/${token}">Resend Verification Mail</a>`
      );
    }

    if (isTokenValid.isVerified) {
      return res.send("Account already verified successfully. Please Login");
    }

    isTokenValid.isVerified = true;

    await isTokenValid.save();

    res.send("Account verified successfully");
  } catch (error) {
    console.log(error);
  }
};

const resend_Verification = async (req, res) => {
  try {
    const { token } = req.params;
    //
    const user = await UserModel.findOne({
      "verificationToken.token": token,
      //Sửa ở đây false -> true
      isVerified: false,
    });
    console.log("Test--------------");
    console.log(user.isVerified);
    //

    const verificationToken = otp_generator.generate(6, {
      upperCaseAlphabets: false,
      specialChars: false,
    });

    // Date
    const expires = new Date();
    expires.setMinutes(expires.getMinutes() + 5); // After 5 minuts, it will be expired

    //-------------------------------------------
    user.verificationToken = {
      token: verificationToken,
      expires: expires,
    };
    // Save to DB: by newUser.save()
    await user.save();
    console.log("Test--------------");
    console.log(verificationToken, expires);

    // send mail to user with register
    const emailBody = `<p>Please click on the link to verify your account. <b>http://localhost:5000/user/verify/${verificationToken}</b></p>`;
    const subject = `Verification Email`;
    await sendEmail(user.email, subject, emailBody);

    res.send("Please check your email for a new verification link");
  } catch (error) {
    res.send("Something went wrong!");
    console.log(error);
  }
};

//*********************************** */
const updateUser = async (req, res) => {
  try {
    const { id } = req.decodedData;
    const { type } = req.body;

    console.log(id);
    console.log(req.body);

    const user = await UserModel.findById(id);

    console.log(user);

    switch (type) {
      case "username": {
        user.username = req.body.newUserData.username;
        await user.save();

        // send mail to user with register
        const emailBody = `<p>Username updated.</p>`;
        const subject = `User Updated Successfully`;
        await sendEmail(user.email, subject, emailBody);

        break;
      }

      case "email": {
        user.email = req.body.newUserData.email;
        await user.save();

        // send mail to user with register
        const emailBody = `<p>Email updated.</p>`;
        const subject = `Email Updated Successfully`;
        await sendEmail(user.email, subject, emailBody);

        break;
      }

      case "password": {
        const hashPassword = await bcrypt.hash(
          req.body.newUserData.password,
          10
        );
        user.password = hashPassword;
        await user.save();

        // send mail to user with register
        const emailBody = `<p>Password updated.</p>`;
        const subject = `Password Updated Successfully`;
        await sendEmail(user.email, subject, emailBody);

        break;
      }
    }
    console.log(user);

    res.json({ message: "User Updated Successfully" });
  } catch (error) {
    res.error({ message: `Something went wrong` });
  }
};

//*********************************** */
const forgotPassword = async (req, res) => {
  try {
    console.log(req.body);
    const isUserExisting = await UserModel.findOne({ email: req.body.email });

    if (!isUserExisting) {
      return res
        .status(400)
        .json({ message: `User with ${req.body.email} don't exists` });
    }

    if (req.body.isOTPVerified) {
      const hashedPassword = await bcrypt.hash(req.body.password, 10);

      isUserExisting.password = hashedPassword;
      await isUserExisting.save();

      // send mail to user with register
      const emailBody = `<p>Your password reset was successfully</p>`;
      const subject = `Password Reset Successfully`;
      await sendEmail(isUserExisting.email, subject, emailBody);

      return res.status(200).json({ message: "Password Reset Successfully" });
    }

    // verificationToken
    const OTP = otp_generator.generate(6, {
      upperCaseAlphabets: false,
      specialChars: false,
    });

    // Date
    const expires = new Date();
    expires.setMinutes(expires.getMinutes() + 5); // After 5 minuts, it will be expired

    isUserExisting.OTP_VerificationToken = { OTP, expires };

    await isUserExisting.save();

    // send mail to user with register
    const emailBody = `<p>Your OTP for password reset request is <b>${OTP}</b> <br> OTP expires in 5 minutes</p>`;
    const subject = `Password Reset Email`;
    await sendEmail(isUserExisting.email, subject, emailBody);

    res
      .status(200)
      .json({ message: "OTP Sent Successfully. Please check your email" });
  } catch (error) {
    res.status(500).json({ message: `Something went wrong` });
  }
};

//*********************************** */
const verifyPasswordOTP = async (req, res) => {
  try {
    const { OTP } = req.body;

    const isOtpValid = await UserModel.findOne({
      "OTP_VerificationToken.OTP": OTP,
      "OTP_VerificationToken.expires": { $gt: new Date() },
    });

    console.log(isOtpValid);

    if (!isOtpValid) {
      return res.status(400).json({ message: "OTP Expired" });
    }

    res.status(200).json({ message: "OTP Verified Successfully" });
  } catch (error) {
    return res.status(500).json({ message: "Something went wrong" });
  }
};

//*********************************** */
const getUser = async (req, res) => {
  try {
    console.log(req.decodedData);

    // ! Find the user
    const { id } = req.decodedData;

    // to take data based on ID
    const data = await UserModel.findById(id);

    console.log(data);

    // User is object one
    const user = {
      email: data.email,
      username: data.username,
    };

    // Get data to push Network / frontend => tra ve json
    res.json({ user: user });
  } catch (error) {
    res.status(500).json({ message: "Something went wrong" });
  }
};

//*********************************** */
// ! Public Profile
const profilePublic = asyncHandler(async (req, res) => {
  // Ensure req.decodedData exists
  if (!req.decodedData || !req.decodedData.id) {
    return res.status(400).json({ message: "Invalid request data" });
  }

  // Find the user
  console.log("test 7");
  // console.log(req.query); // Changed from req.params to req.query
  const courseIdParam = req.query.courseId; // Changed from req.params to req.query
  const user = await UserModel.findById(req.decodedData.id).populate({
    path: "progress",
    populate: [
      {
        path: "courseId",
        model: "Course",
        populate: {
          path: "sections",
          model: "CourseSection",
        },
      },
      {
        path: "sections.sectionId",
        model: "CourseSection",
      },
    ],
  });

  console.log(user);
  if (!user) {
    return res.status(404).json({ message: "User not found" });
  }

  // Filter progress for a specific course if courseIdParam is provided
  const courseProgress = courseIdParam
    ? user.progress.find((p) => p.courseId._id.toString() === courseIdParam)
    : null;

  console.log("Test 8");
  console.log(courseProgress);

  // ! If a specific course progress is found, calculate its summary
  let progressSummary = null;
  if (courseProgress) {
    const totalSections = courseProgress.courseId.sections.length;
    let completed = 0,
      ongoing = 0,
      notStarted = 0;
    courseProgress.sections.forEach((section) => {
      if (section.status === "Completed") completed++;
      else if (section.status === "In Progress") ongoing++;
      else notStarted++;
      // Prepare the data
      console.log(courseProgress.courseId.title);
      progressSummary = {
        courseId: courseProgress.courseId._id,
        courseTitle: courseProgress.courseId.title,
        totalSections,
        completed,
        ongoing,
        notStarted,
      };
      res.json({
        message: "Welcome to your profile",
        progressSummary,
      });
    });
  }
});

//*********************************** */
// ! Private Profile
const privateProfile = asyncHandler(async (req, res) => {
  // Ensure req.decodedData exists
  // if (!req.decodedData || !req.decodedData.id) {
  //   return res.status(400).json({ message: "Invalid request data" });
  // }

  // Find the user
  const user = await UserModel.findById(req.user).populate({
    path: "progress",
    populate: [
      {
        path: "courseId",
        model: "Course",
        populate: {
          path: "sections",
          model: "CourseSection",
        },
      },
      {
        path: "sections.sectionId",
        model: "CourseSection",
      },
    ],
  });

  console.log(user);
  if (!user) {
    return res.status(404).json({ message: "User not found" });
  }

  // Calculating the progress statistics for each course
  const courseProgress = user.progress.map((courseProgress) => {
    const totalSections = courseProgress.courseId.sections.length;
    let completed = 0,
      ongoing = 0,
      notStarted = 0;
    courseProgress.sections.forEach((section) => {
      if (section.status === "Completed") completed++;
      else if (section.status === "In Progress") ongoing++;
      else notStarted++;
      return {
        courseId: courseProgress.courseId._id,
        courseTitle: courseProgress.courseId.title,
        totalSections,
        completed,
        ongoing,
        notStarted,
      };
    });
    // Prepare the response
    const response = {
      totalCourses: user.progress.length,
      courseProgress,
    };
    res.json(response);
  });

  console.log("Test 8");
  console.log(courseProgress);
});

//*********************************** */
// ! Lists
const lists = asyncHandler(async (req, res) => {
  const { courseId } = req.params;

  // ! Validate the courseId
  if (!mongoose.Types.ObjectId.isValid(courseId)) {
    return res.status(400).json({ message: "Invalid Course Id" });
  }

  // ! Find all users and populate their progress with course details
  const users = await UserModel.find({}).populate({
    path: "progress",
    populate: {
      path: "courseId",
      model: "Course",
      populate: {
        path: "sections",
      },
    },
  });

  // ! Filter and map users' progress data
  const userProgressData = users
    .map((user) => {
      const courseProgress = user.progress.find(
        (cp) => cp.courseId && cp.courseId._id.toString() === courseId
      );

      console.log(courseProgress);
      if (!courseProgress) {
        return null;
      }

      // ! Get total sections
      const totalSections = courseProgress.courseId.sections.length;
      // ! Call the sections completed
      const sectionsCompleted = courseProgress.sections.filter(
        (section) => section.status === "Completed"
      ).length;
      console.log(sectionsCompleted);
      // ! Calc percentage progress
      const progressPercentage =
        totalSections > 0
          ? parseFloat((sectionsCompleted / totalSections) * 100).toFixed(1)
          : 0;
      return {
        id: user._id,
        email: user._email,
        role: user._role,
        totalSections,
        sectionsCompleted,
        position: null,
        username: user.username,
        dateJoined: user.createdAt,
      };
    })
    .filter((item) => item !== null);
  // ! Sort users based on sectionsCompleted and assign positions
  // ! Sort users based on sectionCompleted
  userProgressData.sort((a, b) => b.sectionsCompleted - a.sectionsCompleted);
  // ! Assign positions with dense ranking
  let lastRank = 0;
  let lastSectionsCompleted = -1;
  userProgressData.forEach((user) => {
    if (user.sectionsCompleted !== lastSectionsCompleted) {
      lastRank++;
      lastSectionsCompleted = user.sectionsCompleted;
      user.position = `${lastRank}${
        ["st", "nd", "rd"][(((lastRank + 90) % 100) % 10) - 1] || "th"
      }`;
    }
  });

  res.json({
    userProgressData,
  });
});

//******************************************************************* */
module.exports = {
  register,
  login,
  verifyUser,
  resend_Verification,
  updateUser,
  forgotPassword,
  verifyPasswordOTP,
  getUser,
  profilePublic,
  privateProfile,
  lists,
};
